"""This file was auto-generated by sqlsynthgen but can be edited manually."""
from mimesis import Generic, Numeric, Person
from mimesis.locales import Locale
import sqlalchemy
from sqlsynthgen.base import FileUploader, TableGenerator, DistributionGenerator
from sqlsynthgen.main import load_metadata

generic = Generic(locale=Locale.EN_GB)
numeric = Numeric()
person = Person()
dist_gen = DistributionGenerator()

from sqlsynthgen.providers import (
{% for provider_import in provider_imports %}
    {{ provider_import }}{%- if not loop.last %},{%- endif %}
{% endfor %}
)
{% for provider_import in provider_imports %}
generic.add_provider({{ provider_import }})
{% endfor %}

metadata = load_metadata("{{ orm_file_name }}", "{{ config_file_name }}")

{% if row_generator_module_name is not none %}
import {{ row_generator_module_name }}
{% endif %}
{% if story_generator_module_name is not none %}
import {{ story_generator_module_name }}
{% endif %}

{% if src_stats_filename %}
import yaml
with open("{{ src_stats_filename }}", "r", encoding="utf-8") as f:
    SRC_STATS = yaml.unsafe_load(f)
{% endif %}

{% for table_data in vocabulary_tables %}
{{ table_data.variable_name }} = FileUploader(metadata.tables["{{ table_data.table_name }}"])
{% endfor %}

{% for table_data in tables %}
class {{ table_data.class_name }}(TableGenerator):
    num_rows_per_pass = {{ table_data.rows_per_pass }}

    def __init__(self):
        self.initialized = False

    def __call__(self, dst_db_conn, get_random):
        if not self.initialized:
            {% for constraint in table_data.unique_constraints %}
            query_text = f"SELECT {%
                for col in constraint.columns
                %}{{col.name}}{%- if not loop.last %}, {% endif %}{%
                endfor
            %} FROM {{table_data.table_name}}"
            query_result = dst_db_conn.execute(sqlalchemy.text(query_text)).fetchall()
            self.{{constraint.name}}_existing = set([
                hash(tuple(result))
                for result in query_result
            ])
            {% endfor %}
            self.initialized = True
        result = {}
        columns_to_generate = set({{ table_data.nonnull_columns }})
        {% for choice in table_data.column_choices %}
        p = get_random()
        {% for probability, columns in choice.options %}
        {%+ if not loop.first %}el{%+ endif %}if p < {{ probability }}:
            columns_to_generate.update(set({{ columns }}))
        {% endfor %}
        {% endfor %}
        {% if max_unique_constraint_tries is not none %}
        max_tries={{max_unique_constraint_tries}},
        {% endif %}
        while columns_to_generate:
            {% if max_unique_constraint_tries is not none %}
            if max_tries == 0:
                raise RuntimeError(f"Failed to satisfy unique constraints for table {{table_data.table_name}} after {{ max_unique_constraint_tries }} attempts.")
            max_tries -= 1
            {% endif %}
            {% for row_gen in table_data.row_gens %}
            if ({% for vn in row_gen.variable_names %}
                "{{vn}}" in columns_to_generate{%- if not loop.last %} or{% endif %}
                {% endfor %}
            ):
                {% for vn in row_gen.variable_names %}
                result["{{vn}}"]{%- if not loop.last %}, {% endif %}
                {% endfor %} = {{ row_gen.function_call.function_name }}({{ row_gen.function_call.argument_values| join(", ") }})
            {% endfor %}
            columns_to_generate = set()
            {% for constraint in table_data.unique_constraints %}
            {{constraint.name}}_hash = hash((
                {% for col in constraint.columns %}
                result["{{col.name}}"],
                {% endfor %}
            ))
            if {{constraint.name}}_hash not in self.{{constraint.name}}_existing:
                self.{{constraint.name}}_existing.add({{constraint.name}}_hash)
            else:
                {% for col in constraint.columns %}
                columns_to_generate.add("{{col.name}}")
                {% endfor %}
            {% endfor %}
        return result
{% endfor %}

table_generator_dict = {
{% for table_data in tables %}
    "{{ table_data.table_name }}": {{ table_data.class_name }}(),
{% endfor %}
}


vocab_dict = {
{% for table_data in vocabulary_tables %}
    "{{ table_data.dictionary_entry }}": {{ table_data.variable_name }},
{% endfor %}
}

{% for gen_data in story_generators %}
def {{ gen_data.wrapper_name }}(dst_db_conn):
    return {{ gen_data.function_call.function_name }}({{ gen_data.function_call.argument_values| join(", ") }})
{% endfor %}

story_generator_list = [
    {% for gen_data in story_generators %}
    {
        "function": {{ gen_data.wrapper_name }},
        "num_stories_per_pass": {{ gen_data.num_stories_per_pass }},
        "name": "{{ gen_data.function_call.function_name }}",
    },
    {% endfor %}
]
